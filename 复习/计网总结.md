# 计算机网络

### 第一章 计算机网络和因特网

> 概念多，主要是各个层级的联系关系

* 应用层  如HTTP、FTP
* 传输层  如TCP、UDP
* 网络层  如IP
* 链路层  如PPP、以太网
* 物理层

==名词解释==

因特网服务提供商（**ISP**）：端系统通过ISP上网，ISP有相当层级关系，如区域ISP、主干ISP等。

因特网交换点（**IXP**）：一个汇合点，多个ISP在这里一起对等。



#### 网络划分

* 网络边缘
  * 主机host/端系统endsystem：客户机client/服务器server
  * 位于数据中心的服务器
* 网络核心
  * 路由器
  * 网络的网络

通信方式

* 客户/服务器模型（**C/S**）
* 对等模型（**P2P**）
* 混合模型（**C/S+P2P**）





#### 网络接入

边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器（**router**）。

接入方式

* 点对点方式接入：电话线（ADSL）、光纤到户（FTTH）、卫星
* 以太网（有线）/WiFi（无线以太网）方式接入
* 广域无线接入：3G、4G、5G网络



#### 分组交换与电路交换

`电路交换网络`

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/01.png" alt="01" style="zoom: 50%;" />

数据交换过程

1.建立连接

2.交换数据

3.释放连接





`分组交换网络`

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/02.png" alt="02" style="zoom:50%;" />

数据交换过程

1.长数据切小段：在发送端，先把较长的报文划分成较短的、固定长度的数据段。

2.生成分组：每个数据段前添加首部

3.发送数据：以“分组”==**packet**==作为数据传输单元，依次把各分组发送到接收端

4.接收数据：接收端收到分组后剥去首部还原成报文

5.在接收端把数据复原



分组交换网络特点

* 将报文分成若干个分组
* 在每个交换节点采用存储转发技术
* 每个分组可能传送路径不同
* 节点间存在冗余路由（指多条路径）
* 网络核心中的每个交换节点均为共享节点



分组交换网络可分为两类

* 数据报网络：完全按照分组交换网络的原理进行工作（纯分组交换）
* 虚电路网络：为了获得一些电路交换的优点，在分组交换网上模拟一些电路交换的特点



#### 网络核心

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/03.png" alt="03" style="zoom:67%;" />



#### 时延、丢包、吞吐量

总时延***d*** *nodal* = 处理时延***d*** *proc* + 排队时延***d*** *queue* + 传输时延***d*** *trans* +  传播时延***d*** *prop*

==注意==  **传输** 指将分组所有的比特推向链路的过程。 **传播** 指数据在点到点链路中的传播。



**流量强度** *La/R*   R=链路带宽 (bps)       L=分组长度 (bits)      a=平均分组到达速率

* La/R ~ 0: 平均排队时延很小，甚至为0
* La/R < 1: 时延较小，且会随时间推延而变小
* La/R = 1: 时延不会变化，具体数值取决于当时队列长度
* La/R > 1: 平均时延较大，且随时间推延而趋于无穷



**吞吐量**  在发送方与接收方之间传输比特的速率。

**瓶颈链路**  在端到端路径上限制了端到端平均吞吐量的那一段链路。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/04.png" alt="04" style="zoom:50%;" />





#### 层次化的网络体系结构(概念)

**实体** *Entity* ：任何可以发送和接收信息的硬件和软件进程。通常是一个特定的软件模块。

**对等体** *Peer*：不同机器上包含对应层的实体称为对等体。

**服务** *Service*：为保证上层对等体之间能互相通信，下层向上层提供的功能。

**接口** *Interface*：接口位于每对相邻层之间，定义了下层向上层提供的原语操作和服务。

**协议数据单元** *PUD*：对等层次上，传送数据的单位。

**服务数据单元** *SDU*：层与层之间交换数据的单位。

**网络体系结构** *Network Architecture*：层和协议的集合。

**协议栈** *Protocol Stack*：一个特定的系统所使用的一系列协议（每层一组协议）。



#### 网络体系结构模型(两种)

`因特网5层模型（协议栈）`

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/05.png" alt="05" style="zoom:50%;" />



`ISO的7层模型（OSI）`

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/06.png" alt="06" style="zoom:50%;" />



==5层模型下的报文封装==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L1/07.png" alt="07" style="zoom:50%;" />





### 第二章 应用层

#### 三种体系

* 客户机/服务器体系结构

存在一个能够相客户机提供服务的服务器。如，Web服务器。

存在一个或多个主动连接服务器，试图从服务器那获取所需服务的客户机。如，IE浏览器。

==注意==  客户机之间不能相互通信。且通常采用服务器集群。



* P2P体系结构，如迅雷，PPLive

任何一方既提供服务又享受服务。

节点之间可以直接通信。

节点的地址和他们之间的连接可能随时发生变化。



* 混合体系结构

C/S体系结构和P2P体系结构的混合体。



#### 两种运输服务

* TCP服务

1. 面向连接：在客户端和服务器进程间需要建立连接。
2. 可靠传输：在发送和接收进程之间。
3. 流量控制：发送数据的速度绝不超过接收速度。
4. 拥塞控制：当网络超负荷时，通知发送端口，减缓发送速度。
5. 不提供实时性和最小带宽承诺。



* UDP服务

1. 在客户端和服务器进程间实现“不可靠的”数据传输。
2. 不提供：连接建立， 可靠性保证，流量控制，拥塞控制，实时性，最小带宽承诺。



**服务的适用性**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/01.png" alt="01" style="zoom:50%;" />



对于TCP/UDP的安全性说明：

TCP和UDP不具备安全性，需要使用**安全套接字层SSL**。SSL位于应用层和TCP之间。

SSL的作用：1. 提供加密的TCP连接；2. 数据的完整性检查； 3. 端点身份鉴别。



#### 套接字 Socket

每个网络应用进程都有属于自己的套接字。

*套接字*  =  *主机地址 IP（32位）* +  *端口号地址  port number（16位）*





#### Web和HTTP

Web属于C/S模式。

信息表达协议——HTML

信息传输协议——HTTP



**Web内容的表达**

Web页面由对象构成，包括HTML文件、JPEG图片、音频文件、Java Applet等

任何一个对象可以通过**URL**来定位。如 *www. hust.edu.cn(主机名)*  */cs/pic.gif (路径名)*



**Web内容的传输**

http：TCP传输服务

1. 客户端启动TCP连接（创建套接字）到服务器，端口号为80；
2. 服务器接收来自客户端的TCP连接；
3. http报文（应用层协议报文）在浏览器和Web服务器之间进行交换；
4. 关闭TCP连接。



##### HTTP1.0传输

非持久性连接

1a. http客户端启动TCP连接到 *www.hust.edu.cn* 上的http服务器（进程）。Port 80是http服务器的默认端口。

1b. 在 *www.hust.edu.cn* 上的http服务器在port 80等待TCP连接请求。“接受”连接并通知客户端。

2.http客户端发送**http请求报文**（包括URL）进入TCP连接插口。

3.http服务器接收到请求报文，形成**响应报文**（包含了所请求的对象，cs/home.index），将报文送入插口。

4.http服务器关闭TCP连接。

5.http客户端接收到包含html文件的响应报文。分析html文件，发现10个引用的jpeg对象。

6.对10个jpeg对象逐个重复1-5步。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/02.png" alt="02" style="zoom:50%;" />

*总时间* = *2RTT* + *文件传输时间*



##### HTTP1.1传输

持久连接

区别：服务器在发送响应后，不再断开TCP连接，而是保持该连接，用于后续对象的传送，直至该连接“休息”了一个较长的时间后，方断开该连接。

特点：减少了对服务器端连接数的需要，从而减少了对服务器端套接字资源的占用，提高了服务器的负载能力。

持久连接分为：

* 非流水线方式：一个对象传输完成方传输下一个。
* 流水线方式：可以一次性发送所有请求，慢慢接收。



##### HTTP请求报文

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/03.png" alt="03" style="zoom:67%;" />

==请求行支持的方法==

* GET：向服务器请求URL的对象，实体体(*entity* *body*)为空。

如果一个表单使用GET方法，填写的是“monkey”和“bananas”，那么URL结构为 *www.somesite.com/animalsearch?monkey&banana*

* POST：用于向服务器提交表单数据也可以同时请求一个WEB页面。实体体内包含用户在表单字段的输入内容。
* HEAD：当服务器收到时，返回响应报文，但不包含请求对象。常用来调试跟踪。
* PUT：常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径。上传文件放在实体体内，目标路径由URL表明。
* DELETE：允许用户或应用程序删除Web服务器上的对象，由URL指定。



##### HTTP响应报文

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/04.png" alt="04" style="zoom: 67%;" />

> Data：服务器产生并发送该响应报文的日期和时间。
>
> Last-Modified：指示了对象创建或者最后修改的日期和时间。
>
> Content-Length：指示了被发送对象中的**字节数**。
>
> Content-Type：应该用正式的首部行，不是文件后缀名。



==常见的HTTP响应状态码和短语==

* 200 OK ：请求成功，被请求的对象在报文中。
* 301 Moved Permanently：请求对象被永久转移，新的URL在响应报文的Location：首部行中。
* 400 Bad Request：服务器不理解请求。
* 404 Not Found：被请求的文档不在服务器上。
* 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。



##### 用户与服务器的交互：cookie

cookie技术的组成部分：

* 在HTTP响应报文中有Set-cookie: 首部行
* 在HTTP请求报文中也有cookie: 首部行
* 在用户的端系统中保留了一个cookie文件，由用户浏览器管理
* 在Web站点有一个后端数据库



<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/05.png" alt="05" style="zoom:50%;" />

##### Web缓存

==不使用缓存器==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/06.jpg" alt="06" style="zoom: 25%;" />

假设对象的**平均长度为1Mb**，从机构内的浏览器对这些初始服务器的平均访问速率为**每秒15个请求**。设HTTP请求报文小到忽略，因而不会在接入链路上产生通信量。还假设从因特网接入链路一侧的路由器转发HTTP请求报文到收到响应报文用时**平均为2s**。

*局域网的流量强度* = *15个请求 / s* ×  *1Mb / 请求*  ÷ *100Mbps* = 0.15

 *接入链路的流量强度* = *15个请求 / s* ×  *1Mb / 请求*  ÷ *15Mbps* = 1



==使用缓存器==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L2/07.jpg" alt="07" style="zoom:25%;" />

实践中的命中率（*由一个缓存器所满足请求的比率*）一般在0.2~0.7之间。

假设上述情况的命中率为0.4，该请求响应时延约为10ms。

那么平均时延为 0.4 × 0.010s + 0.6 × 2.01s ≈ 1.2s





### 第三章 运输层

#### 运输层概述

功能：为不同主机上运行的应用进程间提供**逻辑通信**。

内容：运输层协议在端系统中实现的。

* 发送方 把应用数据划分成报文段（*segment*），交给网络层。
* 接收方 把报文段重组成应用数据，交给应用层。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/01.png" alt="01" style="zoom:50%;" />

两种协议：

* UDP（用户数据报协议）：不可靠、无连接
* TCP（传输控制协议）：可靠、面向连接



#### 多路复用和多路分解

多路复用：多个进程通过**各自端口**将数据交付给运输层，共同使用运输层的服务。

多路分解：当运输层收到从下层网络层传递上来的数据后，通过端口号就数据向上交付给各自的应用进程。



**端口**（16bit的端口号标志）

作用：让应用层各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程（或者线程）。



**套接字**（socket）

**IP地址 **在互联网上**唯一标识一台主机**，**端口号** 在一台主机**唯一标识一个应用进程**，将两者结合起来，可以在互联网上唯一的标识通信双方的一个端点，即应用进程，这两者的组合称为套接字。



##### 面向连接的复用和分解

TCP套接字：（四元组） 源IP地址 + 源端口号 + 目的IP地址 + 目的端口号

* 接收方主机根据这四个值将报文段定向到相应的套接字。

* 服务器主机同时支持多个并发的TCP套接字，且每一个套接字都由其四元组来标识。
* Web服务器为每一个客户连接都产生不同的套接字，非持久HTTP对每一个请求都建立不同的套接字（会影响性能）。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/02.png" alt="02" style="zoom:50%;" />



##### 无连接的复用和分解

UDP套接字：（二元组）  目的IP地址 + 目的端口号

* 接收方根据目的端口号将报文段定向到相应的套接字。
* 具有不同源IP地址和/或源端口的UDP报文如果具有相同的目的IP地址和目的端口号，则定向到相同的套接字。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/03.png" alt="03" style="zoom:50%;" />





#### 无连接传输：UDP

**处理数据流程**

* 发送方
  1. 从应用进程得到数据。
  2. 附加上为多路复用和多路分解所需的源和目的端口号及差错检测信息，形成数据报。
  3. 递交给网络层，尽力而为的交付给主机。
* 接收方
  1. 从网络层接收数据报。
  2. 根据目的端口号，将数据交付给相应的应用进程。



优势：

1. 无需建立连接——建立连接时会增加时延；
2. 简单——发送方和接收方无需维护连接状态
3. 段首部开销小——TCP：20Byte和UDP：8Byte
4. 无拥塞控制——UDP可按需随时发送



使用UDP过多导致：

1. 路由器中的分组大量溢出；
2. 显著减小TCP通信的速率，甚至挤垮TCP会话。



报文结构：

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/04.png" alt="04" style="zoom:50%;" />

**检查和**

发送方：

* 把报文段看作是16比特字的序列；
* 检查和：对报文段的所有16比特字的和进行1的补运算；
* 发送方将计算校验和的结果写入UDP检验和字段中。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/05.png" alt="05" style="zoom: 33%;" />

接收方：

* 计算接收到的报文段的检验和；
* 检查计算结果是否与收到报文段的校验和字段中的值相同，不同则检查到错误；相同则没有检测到错误，但仍可能有错。





#### 可靠数据传输原理（rdt）

不可靠信道决定了可靠数据传输协议（*rdt*）的复杂性。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/06.png" alt="06" style="zoom:50%;" />



##### rdt1.0 ：经完全可靠信道的可靠数据传输

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/07.png" alt="07" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/08.png" alt="08" style="zoom:50%;" />



##### rdt2.0 ：经具有比特差信道的可靠数据传输

假设分组比特可能受损，但分组不会丢失。



> 处理机制
>
> * 如何判断分组受损——**差错检测**
> * 如何通知发送方分组受损——**接收方反馈（ACK，NAK）**
> * 得知受损后，发送方如何处理——**出错重传**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/09.png" alt="09" style="zoom:50%;" />

其中，rcvpkt是接收方返回的数据包。corrupt是包出错，notcorrupt是包没错。



##### rdt2.1 ：解决重传出现的问题和反馈出现的问题

rdt2.0出现问题：反馈ACK或NAK受损，接收方无法分辨文件是重传的还是新的。

对上述问题的逐步解决：

> 对重复分组，发送方对每个分组增加序号即可，由于rdt2.0是一个**停止等待协议**，所以用1bit的序号足够了（区分是在重发前一分组和新的分组），序号变化按模2运算计算。
>
> ==停止等待（stop-and-wait）== 发送方发出一个分组，然后等待接收方的应答。

> 对于反馈受损，可以在响应报文中同样增加检验和。



<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/10.png" alt="10" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/11.png" alt="11" style="zoom:50%;" />



##### rdt2.2 ：在上一版本基础上的更新

更新为：取消NAK，ACK与序号绑定。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/12.png" alt="12" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/13.png" alt="13" style="zoom:50%;" />



##### rdt3.0 ：经具有比特差错的丢包信道的可靠数据传输

rdt3.0出现问题：怎样检验丢包，发现丢包后如何处理。

对上述问题的逐步解决：

> 对于检测丢包，等待！设置**倒计数定时器**。

> 对于处理，rdt2.2已经给出答案。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/14.png" alt="14" style="zoom:50%;" />

>  接收方如rdt2.2。



==rdt3.0传输的几个例子==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/15.png" alt="15" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/16.png" alt="16" style="zoom:50%;" />



缺点：效率低下

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/17.png" alt="17" style="zoom:50%;" />



#### 流水线可靠数据传输协议

允许发送方发送多个分组而无需等待确认。

* 必须扩大序号范围
* 协议的发送方和接收方必须对分组进行缓存



##### Go-Back-N（GBN）协议

允许发送方发送多个分组而不需要等待确认，但已发送而未确认的分组数不能超过N。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/18.png" alt="18" style="zoom: 67%;" />

> 分组首部用k-bit字段表示序号。

**累积确认：**对序号为n的分组的确认采取累积确认的方式，表明接收方已收到序号n以前且包括n在内的所有分组。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/19.png" alt="19" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/20.png" alt="20" style="zoom:50%;" />

> 接收方只需要记住expectedseqnum。



==GBN协议的例子==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/21.png" alt="21" style="zoom:50%;" />



特点：

* 发送端窗口 ≤ 2的k次方-1，接收端窗口大小为1
* ACK（n）：接收方对序号n之前包括n在内的所有分组都确认了
* 为base的分组设置一个统一的定时器
* 超时（n）：重传分组n和窗口中所有序号大于n的分组
* 接收方不缓存分组，只发最高序号分组的ACK





##### 选择重传（SR）协议

特点：

* 接收方**逐个**对所有正确收到的分组进行确认，故收到的可能是失序的分组。
* 接收方对失序的分组进行缓存，以便最后有序递交。
* 发送方只重发怀疑丢失或损坏的分组，为每一个没有收到ACK的分组设置定时器
* 发送窗口大小为N≤2的k-1次方，[sendbase, sendbase+N-1]，sendbase以前的分组都被确认
* 接收窗口大小为N≤2的k-1次方，[recvbase, recvbase+N-1]，落在窗口内的都是期待收到的分组序号，之前的是按序的且发出确认的。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/22.png" alt="22" style="zoom:50%;" />



**发送方过程**

从上层收到数据 :
* 如果下一个可用于该分组的序号在窗口内，则将数据打包并发送。否则要么缓存，要么拒绝上层

超时(n): 序号为n的分组超时
* 重传分组n, 重置定时器

收到确认(n) 在 [sendbase,sendbase+N-1]范围内
* 标记分组 n 为已接收
* 如果n是发送窗口基序号sendbase，则将窗口基序号前推到下一个未确认序号（因此，sendbase前的分组一定都被确认过了）；如果不是，窗口不动
* 发送方可能会收到比sendbase还小的序号的分组确认，这时什么都不做(因为比sendbase还早的分组都被确认)

> 为什么发送方会收到比sendbase小的ACK（n）
>
> 例如窗口位于sendbase-1时，序号为sendbase-1的分组定时器时间到还没收到Ack(sendbase-1)，则发送方重发该分组。
> 刚重发，收到了Ack(sendbase-1)，窗口前移到sendbase。
> 窗口移动后，又收到了Ack(sendbase-1)。



**接收方过程**

分组序号n在[rcvbase, rcvbase+N-1]范围内 :

* 分组正确接收
* 发送n的确认ACK(n)（不管是否为重复分组及是否失序）
* 如果分组是以前没收到过的：将其缓存
* 如果该分组序号=rcvbase，则将从该分组开始序号连续的分组一起交给上层，然后，窗口按向上交付的分组的数量向前移动

分组序号n 在 [rcvbase-N,rcvbase-1]范围内

* 虽然曾经确认过，仍再次发送n的确认ACK(n)
* 不发确认，发送方窗口无法向前移动

其他情况

* 忽略该分组

> 为什么接受方会收到[rcvbase-N，rcvbase - 1]范围内的分组？并且必须给出确认？
>
> 因为确认可能会丢失。假设接受方按序收到N个分组，向发送方发送确认后接受窗口向前移动N位。
> 假设确认分组全部丢失，导致发送方重发。发送方最多只能发N个，因此接受方会收到[rcvbase-N，rcvbase - 1]范围内的分组。
> 接收方这时必须给出确认，否则发送方窗口无法向前移动。

> 为什么接受方收到比rcvbase-N更早的分组后不用发确认了？
>
> 因为比rcvbase-N更早的分组（如rcvbase-N-1 ），发送方一定收到确认了。
> 当接受窗口位于rcvbase时，意味着接受方一定按序收到了从[rcvbase-N, rcvbase - 1]的分组
> 这意味着发送方窗口一定至少到了rcvbase-N。因此发送方一定收到了比rcvbase-N更早的确认



==SR协议的例子==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/23.png" alt="23" style="zoom:50%;" />



对于窗口大小，下面的例子可以说明为什么要 ≤2的k-1次方，k为k-bit序列的二进制位数。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/24.png" alt="24" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/25.png" alt="25" style="zoom:50%;" />



#### 面向连接的传输：TCP

##### 几个名词

面向连接：TCP连接仅存在端系统，路由器不知情

全双工服务：可双向同时传输数据

点对点连接：仅存在于两个端系统之间

三次握手：建立连接，协商参数

可靠的字节流：最大报文段长MSS

流量控制与拥塞控制



##### TCP报文首部结构

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/26.png" alt="26" style="zoom:67%;" />

* 源端口号和目的端口号各占2字节，16bit。
* 序号占4字节，32bit——本报文段所发送的数据的第一个字节在整个报文字节流中的序号。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/27.png" alt="27" style="zoom: 50%;" />

* 确认号占4字节，32bit——期望收到对方的下一个报文段的数据的第一个字节的序号。因为TCP连接是双向的。
* 首部长度字段占4bit——==以32bit为单位==的TCP首部长度。（一般为20字节，故为5）
* 保留字段占6bit——为今后使用，但目前应置为 0。
* URG——为1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。（一般不用）
* ACK——只有当 ACK =1 时确认号字段才有效。当 ACK = 0 时，确认号无效。
* PSH——为 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
* RST——为 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
* SYN——为 1时，就表示这是一个连接请求或连接接受报文。
* FIN——为1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
* 窗口字段占2字节，16bit——窗口字段用来控制对方发送的数据量，单位为==字节==。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。
* 检验和占2字节，16bit——范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
* 紧急指针字段2字节，16bit——指出在本报文段中的紧急数据的最后一个字节的序号。
* 选项字段——用于发送方和接收方协商MSS时使用，MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。
  * MSS是TCP报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。
* 填充使得报文首部为4字节的整数倍，长度不定。



##### TCP超时设置

估算RTT：

EstimatedRTT = (1- a) · EstimatedRTT + a · SampleRTT

参考值：a = 0.125

第一次计算时，EstimatedRTT=SampleRTT



考虑RTT波动：

DevRTT = (1-β) · DevRTT + β · |SampleRTT-EstimatedRTT|

参考值：β = 0.25

第一次计算：DevRTT=0.5 · SampleRTT



TCP的超时间隔为：

TimeoutInterval = EstimatedRTT + 4*DevRTT



##### TCP的可靠传输

采用累积确认。



超时间隔加倍：

每一次TCP超时重传均将下一次超时间隔设为先前值的两倍。

超时间隔由EstimatedRTT和DevRTT决定，每当发生下列事件之一是重新计算超时间隔：

* 收到上层应用的数据
* 收到对未确认数据的ACK



快速重传：在超时到来之前重传报文段

超时周期往往太长

* 增加重发丢失分组的延时

通过重复的ACK检测丢失报文段

* 发送方常要连续发送大量报文段

* 如果一个报文段丢失，会引起很多连续的重复ACK

如果发送收到一个数据的3个重复ACK，它会认为确认数据之后的报文段丢失。



##### TCP流量控制

原因：

* TCP接收方有一个缓存，所有上交的数据全部缓存在里面
* 应用进程从缓冲区中读取数据可能很慢

为了避免发送方因传的太快而时接收方缓存溢出，接收方在反馈时，将缓冲区剩余空间的大小填充在报文段首部的窗口字段中，通知发送方。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/28.png" alt="28" style="zoom:50%;" />

为了不使得接收方缓冲区溢出，必须满足：

*LastByteRcvd – LastByteRead ≤ RcvBuffer*

*RcvWindow = RcvBuffer – [LastByteRcvd - LastByteRead]*

接收方把当前的*RcvWindow*值放入报文的**窗口字段**中，通知发送方自己在该连接的缓冲还有多少空间。



发送方：*LastByteSend*：发送主机上发送的最后一个字节序号
               *LastByteAcked*：发送主机上被确认的最后一个字节序号

发送方必须保证：*LastByteSent – LastByteAcked ≤ RcvWindow*



==一种特殊情况==

情景：接收方通知发送方RcvWindow为0，且接收方无任何数据传送给发送方。
问题：当接受方的缓冲区被应用进程清空后，接收方没有办法主动发送报文段通知发送方（假设接受方没有数据要发送，而发送方因为得知接收方传递接受窗口为0而被阻塞）。
解决办法：当接收端的接收窗口为0时，发送方持续向接受方发送只有一个字节数据的报文段，目的是试探。



##### 建立TCP连接

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/29.png" alt="29" style="zoom: 67%;" />

==为什么需要三次握手？==

假设只需要二次握手，考虑这种情况：
1：主机A发出的请求报文段在某些网络节点滞留时间太长，主机A由于超时重发连接请求，B收到重发的连接请求后给出同意连接的确认，主机A收到B的确认建立连接。数据传输完毕释放连接。
2：这时第一个请求才到达B，主机B收到该失效的请求后，误以为A又发出请求，于是向主机A发出确认，同意建立连接。主机A则不会理睬该确认。主机B则苦等A的数据。三次握手就可以防止这种情况的发生。（主机A不会对主机B的确认发出确认，连接就建立不起来）

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/30.png" alt="30" style="zoom:50%;" />



##### 断开TCP连接

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/31.png" alt="31" style="zoom:50%;" />





#### TCP拥塞控制

与流量控制做区别：

* 流量控制：为了匹配发送方和接收方的速度，只发生在发送方和接收方之间
* 拥塞控制：网络拥塞时，所有发送方都要抑制发送速度

会出现：1.丢包（路由器缓冲区溢出）；2.延时变长（路由器缓冲区排队）



拥塞控制的方法：

* 网络辅助的拥塞控制（路由器辅助）

  1. 直接网络反馈：路由器以阻塞分组的形式通知发送方“网络拥塞了”

  2. 经由接收方的网络反馈：路由器标识从发送方流向接收方分组中的某个字段以指示拥塞的产生，由接收方通知发送方“网络拥塞了”

* 端到端拥塞控制

  网络层不为拥塞控制提供任何帮助和支持，端系统通过对网络行为（丢包或时延增加）的观测判断网络是否发生拥塞。



**TCP为端到端拥塞控制。**

引入拥塞窗口CongWindow。

*LastByteSent - LastByteAcked ≤ min{CongWin,RcvWindow}*

为方便讨论，考虑RcvWindow为无限大。

发送方的发送速率大概为 *rate = CongWindow / RTT*  Bytes/s



==Reno算法==

1.慢启动（SS）

建立连接时，CongWindow = 1 MSS。

此时可用带宽远大于 MSS/RTT。每收到一次**前面未确认数据的ACK**则将CongWin的值增加一个MSS。

连接初始阶段，以指数的速度增加发送速率，直到发生一个丢包事件为止。



2.拥塞避免（CA）

* 对收到3个重复ACK的反应——快速重传

  * 门限值ssthresh设为当前CongWindow的一半（门限值初始值65kB）

  * 将CongWin减为 新的门限值 + 3MSS
  * 线性增大拥塞窗口

* 对超时事件的反应

  * 门限值设为当前CongWin的一半（门限值初始值65kB）
  * 将CongWindow设为1个 MSS大小
  * 窗口以指数速度增大
  * 窗口增大到新的门限值之后，再以线性速度增大



==举例==

> 当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。水平坐标单位为RTT。

> 慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。

* 超时

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/32.png" alt="32" style="zoom:67%;" />



* 收到三个冗余ACK

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/33.png" alt="33" style="zoom: 67%;" />



**TCP的吞吐量**

假定当丢包事件发生时，窗口大小为 W，吞吐量为**W/RTT**

丢包事件发生后，窗口大小减为W/2, 吞吐量为**W/(2RTT)**

因此平均吞吐量为:  ***0.75 W/RTT***



一条连接的平均吞吐量 = 1.22 × MSS / (RTT × √L )

其中，L为丢包率。



**公平性分析**

公平：如果K个TCP连接共享同一个带宽为R的瓶颈链路, 每个连接的平均传输速率为 R/K。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L3/34.png" alt="34" style="zoom:67%;" />

> 在B点处，会产生丢包。



### 第四章 网络层

#### 网络层概述

网络层的作用：

* 为运输层提供支持。运输层实现进程到进程的通信，需要网络层的服务。
* 为实现从源主机到目标主机成功地转发数据分组，端到端路径上的每台分组交换机上均需实现网络层。



围绕三个问题：

1. 如何选路？
2. 如何转发？
3. 确认是否可达？



##### 虚电路和数据报网络

虚电路服务：面向连接的服务，需要事先握手

数据报服务：面向无连接的服务，事先不握手



**虚电路服务：**

* 收发双方之间的路径如同电话线路一般
* 数据传输前，呼叫建立；传输结束后断开连接
* 每一个分组携带虚电路的标识 (而不是目的主机的地址)
* 路径上的每个路由器必须为进行中的连接维持连接状态信息
* 链路, 路由器资源 (带宽、缓冲区) 可以分配给虚电路

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/01.png" alt="01" style="zoom:67%;" />



虚电路组成：

1. 从源到目的主机的**路径**
2. **VC号**（沿着该路径的每段链路的一个号码）
3. 沿着该路径的每台路由器的**转发表**

==【例如】==在下图的网络中，主机A请求该网络在它自己与主机B之间创建一条虚电路。假设网络为该虚电路选择路径为A-R1-R2-B，并为这路径上三条链路分配VC号12、22和32。在这种情况下分组离开主机A时，VC号是12；离开R1时，VC号为22；离开R2时VC号为32。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/02.png" alt="02" style="zoom: 50%;" />

> 路由器维持连接状态信息！

==为什么一条虚电路上的每条链路虚电路号不同？==

1. 减少VC字段长度
2. 简化了虚电路的建立，在由多个VC号的路径，其上的每条链路能够独立于沿着该路径的其他链路所需的号码选择一个VC号。如果所有链路要求一个共同的VC号的话，路由器不得不交换并处理相当大量的报文，以约定一个共同的VC号。



**数据报服务：**

* 在网络层没有连接建立过程
* 不维护连接状态信息
* 同一对主机间的报文可能会走不同的路径

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/03.jpg" alt="03" style="zoom:67%;" />

转发表采用**地址前缀比配法**，来减小转发表。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/04.png" alt="04" style="zoom:50%;" />



虚电路 VS 数据报

虚电路网络：（聪明的网络，愚笨的终端）

* 保证速率和服务质量
* 定时维持状态

数据报网络：（简单的网络，复杂的终端）

* 互联不同类型的网络更加容易
* 启用新服务速度更快，更简单



##### 网络层与运输层的区别

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/05.png" alt="05" style="zoom:50%;" />

##### 网络层组件构成

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/06.png" alt="06" style="zoom: 50%;" />

* 选路协议
* IP协议
* ICMP协议



#### IP协议

##### IP数据报格式

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/07.png" alt="07" style="zoom:67%;" />



* 版本（4bit）：如IPv4，IPv5，IPv6，版本协议不同，无法通信。

* 服务类型（8bit）：用于服务质量保证。

  * 前3bit表示优先级，第4bit表示要求更低时延，第5比特表示要求更高吞吐量，第6比特表示要求更高可靠性，第7比特表示要求选择费用更低廉的路由，第8比特未用。
  * 最新的服务类型6位定义区分服务，2位保留。

* 报文长度的相关字段：

  * 首部长度（4bit）：单位为==4字节==，取值范围5-15，即20-60字节。
  * 总长度（16bit）：单位是==字节==，取值范围0-65535，实际报文数据长度为总长度减去首部长度。以太网链路帧最多只允许携带1500字节。

* 生存时间（8bit）：记为**TTL**，每当数据报经过一台路由器，该字段值减1。该值为0时被丢弃，避免数据报进入循环路由无法退出。不同系统，TTL默认最大取值不同。

* 协议（8bit）：指出此数据报携带的数据是使用何种协议，以便目的主机的IP层知道应将数据部分上交给哪个处理过程。

  * | 协议号 | 对应协议 | 协议号 | 对应协议 |
    | :----: | :------: | :----: | :------: |
    |   1    |   ICMP   |   8    |   EGP    |
    |   2    |   IGMP   |   17   |   UDP    |
    |   4    |    IP    |   41   |   IPv6   |
    |   6    |   TCP    |   89   |   OSPF   |

* 首部检验和（16bit）：差错检测，只检验首部。

  * 和运输层（TCP、UDP）一起进行重复校验的原因：1.校验的内容不同；2.可能不属于同一个协议栈。

* 源地址和目的地址（32bit）：标识发送端和接收端的IP地址。

* 分片相关字段：

  * IP的分片和重组：

    网络链路具有MTU（最大传输单位）——由链路的层的最大帧的限制决定。**不同类型的链路有不同的MTU。**

    大的IP数据报在网络被分成小的。

    **重组只在目的主机上进行。**标识、标志以及片偏移字段用于目的主机对接收的分片进行重组。
    
  * 标识（16bit）：同一个IP分组的标识。是为了使分片后的各数据报片最后能准确地重装。
  
  * 标志（3bit）：前2bit有意义。最低位为MF，MF=1即表示后面还有分片的数据报，MF=0表示这已是若干数据报片的最后一个。第二位记为DF，当DF=0时才允许分片。
  
  * 片偏移（13bit）：每个分片在整个报文（分组）中的位置，单位为==8字节==。  
  

==举例==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/08.png" alt="08" style="zoom: 50%;" />



##### IP地址

32位主机或路由器的接口（网卡）标志符。

* IP 地址只和接口有关, 而与主机,路由器却没有太多关联。
* 接口：连接主机、路由器之间的物理链路。
  * 一般来说，路由器有多个接口，主机如果插入多块网卡也有多个接口。



**IP地址结构**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/09.png" alt="09" style="zoom: 50%;" />

**IP地址分类**

方便寻址，使网络层次化。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/10.png" alt="10" style="zoom: 67%;" />



**互联网中的示例**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/11.png" alt="11" style="zoom:67%;" />

> 在同一个局域网上的主机或路由器的IP 地址中的网络号必须是一样的。图中的网络号就是 IP 地址中的 net-id。

> 路由器总是具有两个或两个以上的 IP 地址。**路由器的每一个接口都有一个不同网络号的 IP 地址。**



##### IPv4面临的问题

1. 地址空间消耗很快；【NAT解决了这一点】
2. 首部长度不定（20-60字节）；【中间节点（路由器）需要消耗相当资源用于分组处理】
3. 缺少QoS；【Quality of Service 指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。】
4. 安全性不够高。



##### IPv6

**IPv6的数据报格式**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/12.png" alt="12" style="zoom:67%;" />

相比于IPv4的更新：

* 无检查和，中间节点无需计算；

* 中间节点不再负责分片和重组，由端节点负责；

  （运行专门的协议获取到目的地所经过所有链路的最小MTU）

* 首部长度固定为**40字节**，加速中间节点的转发速度。



* 版本（4bit）：IP协议版本号，IPv6将其置为6。

* 流量类型（8bit）：与IPv4的TOS（服务类型）相似。

* 流标签（20bit）：给属于特殊流（flow）的分组加上标签。

  （特殊流指需要特别服务质量的数据流（如实时视频）。流量类型+流标签用于实现QoS）

* 有效载荷长度（16bit）：给出首部后面数据的字节数量。

* 下一个首部（8bit）：标识该数据报中内容（数据字段）需要交付给哪个上层协议（如TCP或UDP）。使用与IPv4中协议字段相同。

* 跳限制（8bit）：转发数据报的每台路由器将该字段内容减一。当跳限制计数到0时，该数据报将被丢弃。同IPV4的TTL。



##### 从IPv4迁移到IPv6

**双栈技术**

* 新加入的设备支持IPv4/IPv6双协议栈。
* 一段链路上，如果源和目标均支持IPv6，则使用IPv6进行通信。
* 如果任一方不支持IPv6，则使用IPv4进行通信。
* 可能会出现信息的丢失。

**隧道技术**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/13.png" alt="13" style="zoom:67%;" />



#### 子网划分

|      | 网络数  |  主机数  |
| :--: | :-----: | :------: |
| A类  |   127   | 16777214 |
| B类  |  16384  |  65534   |
| C类  | 2097150 |   254    |

> 如果主机号n位，则主机数量 = 2^n - 2，主机号全0和全1有特殊含义



==背景问题==

一家跨国公司在海外拥有26家分支机构，包括总部在内，共计27家机构，该公司所有机构共有54320台计算机需要IP地址，总部向ICANN申请了一个B类地址块，现需要分配给所有的机构，如何分配？

1. 由总部管理员统一分配，集中管理。即一个网络号，下面分配54320个主机，管理者开销大。
2. **划分子网**。总部管理员将IP地址分成27个子块，每个机构一块，各机构管理员内部自行分配。



##### 如何划分子网？

从**主机号**中借用一部分，作为**子网号**。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/14.png" alt="14" style="zoom:67%;" />

引入**子网掩码**。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/15.png" alt="15" style="zoom:50%;" />

子网掩码的作用：对外隐藏子网的存在，对内指示网络号和子网号的位置。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/16.png" alt="16" style="zoom:50%;" />



==举例==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/17.png" alt="17" style="zoom:67%;" />

主机1如何将数据发送给IP为128.30.34.128的主机？

 H1 首先检查主机 128.30.34.138 
是否连接在本网络上如果是，则直接交付；
否则，就送交路由器 R1，并逐项查找路由表。



##### 两类问题

Q1. 有一个C类地址：201.222.5.0，需要划分20个子网，每个子网5台主机，则如何划分子网。

> 设置子网掩码为255.255.255.248（255.255.255.11111000）
>
> 5位子网号，3位主机号。
>
> 例如，
>
> 【子网表示格式为：网络地址/子网掩码】
>
> 第一个子网：201.222.5.8/255.255.255.248   （201.222.5.00001000）
>
> 第二个子网：201.222.5.16/255.255.255.248   （201.222.5.00010000）
>
> ... ...



Q2. 某公司现获得了一批IP地址，为218.103.24.112~218.103.24.127
请问：该批IP地址的网络地址是多少？该批IP地址的子网掩码是多少？如果针对该批IP地址进行进一步的子网划分，还可以划分为多少个子网？

> 该批IP为C类地址，因为218 = **110**1 1010。
>
> 218.103.24.112（218.103.24.01110000）~218.103.24.127（218.103.24.01111111）
>
> 网络地址为218.103.24.112，子网掩码为255.255.255.112
>
> 根据扩展子网号的位数，划分的子网数量不等。



#### CIDR（无类别域间路由）

将上述子网划分的概念一般化。

CIDR编址格式：

* IP地址 = {<网络前缀>，<主机号>}
* 地址的网络部分长度任意
* 地址格式: a.b.c.d/x, 这里的 x表示地址中网络部分的位数
* 斜线记法：192.168.0.1/24
* *简写记法：10.0.0.0/10 =>10/10



##### 层次化编址

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/18.png" alt="18" style="zoom:67%;" />

> 这个ISP共有64个C类网络。
>
> 因为：还剩下6位分配的地址，不过这对于CIDR也不太在意，一般来说，只需要关注前面的3位110即可。



层次编址的好处：

1.路由聚合，大大减少路由器转发表中的项数。

==举例==

假设某ISP已经被分配地址块：200.23.16.0/20。ISP将该地址块进一步划分为8块较小的地址块，分配给8个组织。

则ISP只需告诉外界（Internet）：向我发送以200.23.16.0/20开始的任何东西。外界不需要知道该地址块内部的细节。

这种使用单个网络前缀通告多个网络的能力称为路由聚合。路由聚合可以大大减少路由器中转发表中的项数。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/19.png" alt="19" style="zoom:50%;" />



2.更具体的路由

==举例==

假设有一个辅助ISP，其地址块为199.31.0.0/16。组织1现在改为通过辅助ISP与Internet相连。

显然组织1的地址块在该地址块以外。一种方法是对组织1内的所有主机和路由器重新进行编址，使其地址在199.31.0.0/16地址块内，但代价很高。

更好的办法是由辅助ISP

发出通告：向我发送以199.31.0.0/16或200.23.18.0/23开始的任何东西。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/20.png" alt="20" style="zoom:50%;" />



##### CIDR寻址

每个项目由“网络前缀”和“下一跳地址”组成。

| 网络前缀         | 下一跳 |
| ---------------- | ------ |
| 128.30.33.0/25   | 接口0  |
| 128.30.33.128/25 | 接口1  |



应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配(longest-prefix matching)。

网络前缀越长，其地址块就越小，因而路由就越具体。





#### DHCP（动态主机配置协议）

DHCP：从服务器上动态获取IP地址。“即插即用协议”

目标：允许主机加入网络时动态地从网络服务器处获取IP地址(还有默认网关和Local DNS)。

* 允许地址重用
* 支持移动用户



步骤：

1. 主机广播：发送“DHCP发现报文”。使用广播目的地址255.255.255.255，源IP为0.0.0.0。
2. DHCP服务器响应：发送“DHCP提供报文”。仍使用广播地址255.255.255.255。
3. 主机请求IP地址：发送“DHCP请求报文”。
4. DHCP服务器确认：发送“DHCP ACK报文”。



#### NAT（网络地址转换）

本地网络只要使用一个IP地址就可以和外部网络相连：

* 不需要从 ISP处获得大批IP地址: 所有设备可以使用同一个 IP地址
* 可以在不通知外部网络的情况下改变内网主机的IP地址
* 即使改变了ISP也无须改变内网主机的IP地址
* 内网主机对外网主机而言是不可见的、不可寻址的。【一项安全措施】

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/21.png" alt="21" style="zoom: 67%;" />



##### NAT的实现

发送数据报：

外出报文的 <源IP地址，端口号>　替换为　<NAT IP地址，新的端口号>

接收数据报：

接收报文的 <NAT IP地址，端口号>　替换为　<源IP地址，对应的端口号>

替换过程查**NAT转换表**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/22.png" alt="22" style="zoom: 67%;" />



##### NAT内网访问方案

客户端如何与内网的10.0.0.1服务器通信？

**1.端口映射**

采用端口NAT，在路由器中静态的为服务器配置一条记录。

如(138.76.29.7,80) 总是指向(10.0.0.1,80)



**2.通用即插即用UPnP**

用于P2P。

内部主机通过IGD（ Internet Gateway Device ）协议了解公共IP地址。

向路由器注册/移除映射记录
（内部IP，内部端口）→（公共IP，公共端口）

然后，内部主机向外部公开（公共IP，公共端口）



**3.中继**

用于Skype。

1. 10.0.0.1通过NAT与中继建立连接；
2. 客户端与中继建立连接；
3. 中继将两个连接建立中继。





#### 选路算法及协议

##### 概念

几个路由器名词：

* 默认路由器：一台主机“直接”连接到的路由器
* 源路由器：源主机的默认路由器
* 目的路由器：目标主机的默认路由器

选路算法目的：给定一组路由器以及连接路由器的链路，从中找到一条从源路由器到目标路由器**“好的”**路径。



建立模型：

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/23.png" alt="23" style="zoom:50%;" />



##### 选路算法分类

* 根据信息全局性or分散性

  * 集中式选路算法

    所有路由器都知道整个网络拓扑图以及链路的费用信息（如，链路状态**LS**算法 ）

  * 分散式选路算法

    每个路由器仅有与其相连链路的费用信息，通过迭代计算过程与相邻节点交换信息（如，距离向量**DV**算法）

* 根据信息是静态还是动态

  * 静态选路算法

    随着时间的流逝，路由的变化非常缓

  * 动态选路算法

    路由信息可以更快地发生变化，周期性的更新

    可以响应拓扑或链路费用的变化

* 根据是否对负载敏感

  * 负载敏感算法

    链路费用会动态地变化以反映出链路的当前状况

  * 负载迟钝算法

    链路费用不明显地反映链路的当前状况



##### 链路状态选路算法  Dijkstra's

**Dijkstra's（迪克斯特拉）算法**

算法的思想：

1.所有节点都知道网络拓扑和链路费用

* 通过链路状态广播获得信息， 所有节点具有该网络的同一个完整的视图

2.计算从某节点到网络中所有其他节点的最低费用

* 为该节点提供转发表

3.迭代: 经算法的K次迭代后，可知道到K个目的节点的最低费用路径



符号定义：

* *c(x,y)*: 从节点x到节点y的链路费用; 如果x和y不是直连的，则 c(x,y) = ∞
* *D(v)*: 随着算法进行本次迭代，从源节点到目的v的最低费用路径的费用 
* *p(v)*: 从源节点到v沿着当前最低费用路径的前一节点
* *N‘* : 节点子集。v在N‘中，如果从源节点到路径的最低费用路径已知

```
Initialization: 
  N' = {u} 
  for all nodes v 
    if v adjacent to u //adjacent:相邻的
      then D(v) = c(u,v) 
    else D(v) = ∞ 
 
Loop
 find w not in N' such that D(w) is a minimum 
 add w to N' 
 update D(v) for all v adjacent to w and not in N' : 
     D(v) = min( D(v), D(w) + c(w,v) ) 
/* new cost to v is either old cost to v or known 
   shortest path cost to w plus cost from w to v */ 
until all nodes in N' 
```



==举个例子==

求下图中，u节点的转发表。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/24.png" alt="24" style="zoom:80%;" />

过程：

1.通过Dijkstra's算法，画出表格，如下图。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/25.png" alt="25" style="zoom: 67%;" />

2.构造最短路径树。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/26.png" alt="26" style="zoom:67%;" />

3.构造u的转发表。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/27.png" alt="27" style="zoom:67%;" />

**算法复杂度分析**

对于第一次迭代: 需要搜索所有的n个节点以确定出节点w，w不在N’中且具有最低费用。

在所有迭代中需要搜索的节点总数为n(n+1)/2 ，所以链路状态算法在最差情况下复杂性为O(n^2)。

*该算法的一种更复杂的实现，使用一种叫做堆的数据结构，其计算复杂性为 O(mlogn)



**存在震荡问题**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/28.png" alt="28" style="zoom:67%;" />

>  令，链路的费用 = 链路上承载的负载，因此c(u,v)不等于c(v,u)

震荡分析：

从图1开始：z向w发送1单元的流量，x向w发送1单元流量，y向w发送e单元流量
当LS算法再次运行后，x、y到w的最低费用路径是顺时针的，导致流量顺时针流动。再次运行LS算法，又导致流量逆时针流动…



解决方法：

1.强制链路费用不依赖于所承载的流量

* 评价：与初衷不符，无法解决高拥塞的问题，该解决方案pass

2.确保所有的路由器不同时运行LS算法

* 评价：因特网上的路由器自同步，即 即使初始时以同一周期在不同时刻执行算法，但最终算法执行的时机在路由器上变成同步进行且保持下去。
* 进一步优化：随机化路由器发送链路通告的时间



##### OSPF协议

“Open”开放：OSPF协议不是受某一家厂商控制，而是公开发表的。

“SPF”最短路径优先：使用Dijkstra‘s 最短路径算法。



几点说明：

* OSPF 只是最早使用的最短路径算法的路由协议名字，并非代表其他路由选择协议不是“最短路径优先”
* OSPF 并非集中式路由协议，而是分散式路由协议



三个要点：

* 向本自治系统中所有路由器发送信息，使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态
* 只要当链路状态发生变化时，路由器就用洪泛法向所有路由器发送此信息
* 即使链路状态没变化，也要周期性地发送链路状态信息，一般每30min

概括下来

1. **洪泛法**：本路由器向本AS（自治系统）中所有路由器发送信息
2. **消息内容**：与本路由器相邻的所有路由器的链路状态
3. **发生时机**：当链路状态发生变化时开始发送+周期性发送



特点：

所有路由器上均有全网一致的拓扑结构图

更新过程收敛较快

安全：OSPF路由器之间的交换都是经过鉴别的（简单的、MD5的），以确认OSPF通告的真实性，防止伪造和篡改；OSPF通告都是有序列号的，以防止重放攻击

OSPF中支持多条具有相同费用的路径

OSPF支持多播选路和层次路由



缺点：

数据库存储空间占用大

最小生成树耗时大

拓扑变化导致网络动荡



##### 距离向量选路算法

B-F公式：*dx(y)=minv{ c(x,v)+dv(y) }*

* dx(y):节点x到y的当前最低费用
* v是对于x的所有直接邻居

该算法的路由表包含：目的网络号、经过的邻居路由器、到目的网络的距离



==举个例子==

求下图中，u到z的最短转发端口。

已知 dv(z) = 5, dx(z) = 3, dw(z) = 3

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/29.png" alt="29" style="zoom:67%;" />

计算B-F公式：

du(z) = min { c(u,v) + dv(z),
                       c(u,x) + dx(z),
                       c(u,w) + dw(z) }
         = min {2 + 5,
                      1 + 3,
                      5 + 3}  = 4



得出结果：通过u到x的端口转发。



每个节点x维护以下数据：

* 节点x到每个邻居v的费用： c(x,v)
* 节点x的距离向量：Dx = [Dx(y): y ∊ N]，包括了x到N中所有目的地最低费用的当前估计值
* 节点x同时保持它邻居的距离向量，对每个邻居v，x 保持  Dv = [Dv(y): y ∊ N ]



基本思想：

* 每个节点周期性地发送它自己的距离向量给邻居
* 当节点x从邻居那里收到收到一个新的距离向量，它将用B-F方程更新自己的距离向量
* 最终Dx(y) 估算值将**收敛到**实际的最低费用路径的费用



特点：

1.迭代、异步

* 每个本地迭代由下面的事件引起：
  * 本地连接的费用改变
  * 从邻居而来的DV更新消息

2.分布

* 每个节点都要从一个或多个邻居接收距离向量更新消息
  * 在执行计算后，如果有必要，该节点再将计算结果发回给邻居

3.好消息传的快

* 举个例子
  * 最左列为最初的转发表，从左向右依次更替。
  * <img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/30.png" alt="30" style="zoom: 50%;" />



缺点：

坏消息传的慢。

==举例==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/31.png" alt="31" style="zoom: 67%;" />

在链路费用变化前，Dy(x)=4, Dy(z) =1, Dz(x)=5。t0时刻，y与x之间的费用增加到60。

y重新计算 Dy(x)= min{ c(y,x) + Dx(x), c(y,z) + Dz(x) } = min {60+0, 1 + 5} = 6

z收到更新的距离向量后，重新计算 Dz(x) = min{c(z,x) + Dx(x), c(z,y) +Dy(x)} = {50+0,1+6} = 7

y、z之间的报文需要交换44次，直到z最终算出Dz(x)=50

会导致无穷计数问题！



解决方案——**毒性逆转**

如果z通过y选路到达目的地x :

* z将通告y，它到x的距离是无穷大 (所以 y不会通过z到达x)
* t0时刻y与x之间的费用增加到60
* y更新其距离向量，由于Dz(x)=∞,因此新的Dy(x)=60
* z在t1时刻收到新的Dy(x)=60后，马上算出新的Dz(x)=50
* 收到来自z的更新后，y算出新的Dy(x)=51



##### RIP协议

RIP的一些特点：

* 相邻两点间链路上的费用定义为1，即只考虑源到目标经过多少个路由器，或多少“跳”
* 一条路径的最大费用限制为15
* 选路更新消息每30s在邻居之间以**RIP响应报文（RIP通告）**的形式进行交换
* 路由器经过**180s**没有收到来自某个邻居的RIP通告，则认为该邻居已离线，修改选路表，向其它邻居广播
* RIP是一个运行在UDP上的应用层协议（端口520）

> 跳(hop)：是沿着从源路由器到目的子网的最短路径所经过的子网数量（**包括目的子网**）

RIP通告包含了**目的子网、下一跳路由器、以及发送方到其中每个子网的距离的信息**



==举个例子==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/32.png" alt="32" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/33.png" alt="33" style="zoom:50%;" />





##### LS算法 vs.  DV算法

报文复杂性：

* LS：n 个节点, E 条链路,需要发送 O(nE)个报文
* DV：只在直连的邻居之间交换报文

收敛速度：

* LS：是一个要求O(nE)个报文的O(n^2) 算法，可能有震荡
* DV：收敛时间不确定，可能会遇到选路环路和记数无穷问题

健壮性：

* LS：节点能够向其连接的链路广播不正确费用。每个节点只计算自己的转发表，路由计算在某种程度上是分离的，有一定的健壮性
* DV：一个节点可向邻居节点通告其不正确的最低费用路径。每个节点的计算都会传递给它的邻居，错误会通过网络进行传播



##### 层次路由

背景

* 因特网规模过大——数亿个目标网络
  * 路由器无法存储每台主机的选路信息
  * 路由表更新的报文广播将导致无剩余带宽供发送数据使用

故采用**管理自治**的思想。



将路由器聚合到一个区域, **“自治系统” (AS)**

* 在相同AS内的路由器可全部运行同样的选路算法，即**自治系统内部选路协议**
* 在不同AS内的路由器可以运行不同的自治系统内部选路协议



转发表是由AS内部选路算法和AS间选路算法共同决定的

* AS内部选路算法为内部目的地址设置转发表信息
* AS内部选路算法和AS间选路算法共同为外部目的地址设置转发表信息



为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作**区域**

* 每个区域有一个32bit的区域标识符
* 一个区域内的路由器最好不超过200个

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L4/34.png" alt="34" style="zoom:67%;" />

划分区域的好处是利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。

一些补充：

* 一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况
* OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。





### 第六章 链路层和局域网

#### 链路层概述

##### 一些术语

节点：主机和路由器

链路：沿着通信路径连接相邻节点的通信信道。分为有线和无线。

帧：链路层的分组单元



##### 层次结构

链路层负责将网络层数据报封装成**帧**，通过链路从一个节点传输到物理上相邻的下一个节点。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/01.png" alt="01" style="zoom:50%;" />

> 不同链路的链路层协议可能不同
>
> 不同链路层协议可能提供的服务不同



##### 提供服务

* 成帧 、链路访问
  * 将数据加上头部和尾部，封装成数据帧
  * 共享介质的信道访问
  * 帧头部用**MAC地址**标识源和目的  ==与IP有区别==
* 可靠传递
  * 很少用于误码率低的链路  ==光纤、双绞线链路==
  * 多用于误码率高的链路  ==无线链路==
* 流量控制
  * 在相邻收发节点间限制流量
* 差错检测
  * 差错原因：信号衰减和电磁干扰噪声导致出错
  * 接收方检测到错误存在：给发送方发送信号要求重传或丢弃该数据帧
* 差错纠正
  * 接收方检测和纠正帧中错误，不用重传。但很难，开销大
* 半双工和全双工
  * 半双工时，链路两端的节点都能传输分组，但不能同时传输



##### 适配器

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/02.png" alt="02" style="zoom:67%;" />

> 网络适配器，也称网络接口卡（NIC）。

两者的通信：

* 发送方NIC
  * 在一个帧内封装数据报
  * 增加差错检测位，可靠交付，流量检测等
* 接收方NIC
  * 查找错误,可靠交付, 流量控制等
  * 取出数据报，交给网络层

适配器特点：

* 半自治单元
* 帧的接收和发送、检错、丢弃，自主完成
* 向上提交数据需要CPU干预
* 最终受控于CPU
* 实现链路层和物理层的功能



#### 多路访问链路和协议

分成两种链路：

* 点到点链路
* 广播链路



##### 广播链路

单个共享广播信道由多个节点共享

当两个或多个节点同时传输时，会相互干扰，发生**碰撞**



##### 多址访问协议

理想的多址访问协议需要满足：

* 公平性

  假定：信道为速率为R b/s的广播信道，当只有一个节点有数据发送时，该节点的吞吐量为R（充分利用带宽），当M个节点有数据发送时，每个节点吞吐量为R/M

* 全分散控制

  没有特定节点用于调整传输，没有时钟同步

* 简单



分类为以下几类：

1.信道划分协议

* 将信道划分成小的“片”（时隙、频率、编码），然后将“片”分配给节点使用

2.随机访问协议

* 信道没有被分割，允许碰撞，但提供碰撞恢复机制

3.轮流协议

* 节点轮流传送，但数据量大的节点轮流更长时间



##### 信道划分协议

==时分 TDMA（*Time Division Multiple Access*）==

循环访问信道

每个节点在每次循环中得到固定长度的时隙（时隙长度＝传输单个分组时间）

没有数据发送的时隙空闲
例如：6-节点 LAN, 时隙1,3,4 有数据发送, 2,5,6 的时隙空闲

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/03.png" alt="03" style="zoom:50%;" />



==频分 FDMA（*Frequence Division Multiple Access*）==

信道按频谱分成若干频段

每个节点分配固定频段

在频段不用时该部分信道被闲置和浪费

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/04.png" alt="04" style="zoom:50%;" />

==码分 CDMA（*Code Division Multiple Access*）==

见第7章



##### 随机访问协议

当节点有数据发送时，以信道的全部速率R传输，没有主节点起协调作用。当两个或多个节点传送时发送碰撞。

该协议解决：

* 如何检测碰撞
* 如何从碰撞中恢复



以下讨论：

ALOHA、时隙ALOHA

CSMA、CSMA/CD



==纯ALOHA==

第一个无线计算机网络

所有站点都使用统一的频率通过主机交换信息

工作原理：一个节点收到网络层的数据立即发送。如果传输的帧发生了碰撞，该节点在全部传输完碰撞帧后**以概率p重传该帧**，或**以概率1-p等待一帧的传输时间**。等待时间结束后再以概率p重传该帧，或以概率1-p等待另一帧的传输时间。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/05.png" alt="05" style="zoom: 67%;" />

工作效率：在任何给定的时间，一个节点传输一帧的概率是p，假设该帧在t0时刻发送，假设时间单位是一帧的发送时间。

P(t0时刻给定节点成功概率) = P(t0时刻给定节点传送) ·
                                                    P(在 [t0-1,t0]没有其它节点传送 ) ·
                                                    P(在 [t0,t0+1]没有其它节点传送)
                                                = p · (1-p)^(N-1) · (1-p)^(N-1)
                                                = p · (1-p)^2(N-1) 

任意节点传输成功的概率：N · p · (1-p)^2(N-1) 

N->∞时，该式为1/(2e) ≈ 0.184。即只有18.4%的帧传输成功。



==时隙ALOHA==

工作原理：

1：所有帧正好由L比特组成
2：带宽为R，一帧传输时间 = L/R
3：以L/R为单位划分时隙
4：节点只在每个时隙的开始传输帧
5：节点时钟同步，因此每个节点知道时隙什么时候开始
6：如果一个节点发送的帧产生碰撞，该节点以概率p在后续的每个时隙重发该帧，直到该帧无碰撞地传输成功。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/06.png" alt="06" style="zoom:50%;" />

工作效率：

P(一个时隙内给定节点成功概率) 
= P(给定节点传送)  · P(没有其它节点传送 )
= p · (1-p)^(N-1)

任意节点传输成功的概率：N · p · (1-p)^(N-1) 

N->∞时，该式为1/e ≈ 0.368。即有36.8%的帧传输成功。是纯ALOHA的2倍。



==CSMA==

CSMA也即载波侦听多路访问。

工作原理：

传输前监听，如果信道空闲则传送整个帧；否则推迟传送。



CSMA分类：

1.非坚持CSMA

一旦监听到信道忙（即发现有其他站在发送数据），就不再坚持听下去，而是根据协议的算法延迟一个随机的时间后重新再监听。若进行载波监听时发现信道空闲，则将准备好的帧发送出去。

*不能充分利用信道刚刚转入空闲期的这段时间*



2.时隙非坚持CSMA

采用划分时隙的随机接入CSMA协议，协议规定只能在每个时隙开始时才能发送帧。



3.1坚持CSMA

当一个站点要传送数据时，首先侦听信道，看是否有其他站点正在传送。如果信道正忙，它就持续监听直到它侦听到信道空闲时，便将数据送出。若发生冲突，站点就等待一个随机长的时间，然后重新开始。

*容易在上述这段时间产生冲突*



4.P坚持CSMA

当一个站点要传送数据时，首先侦听信道，看是否有其他站点正在传送。如果信道正忙，它就持续监听直到它侦听到信道空闲时，以概率P发送数据，而以概率（1－P）延迟一段时间τ (网络中最远的端到端的传播时延)，重新监听信道。若发生冲突，站点就等待一个随机长的时间，然后重新开始。

*可以在一定程度上克服这些缺点，但却很难选择一个能用于各种通信量强度的P值，所以在实际网络中常选择1坚持*



有检测时，为什么会发送碰撞？

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/07.png" alt="07" style="zoom:67%;" />

> 整个包的传输时间被浪费



==CSMA/CD==

载波侦听/碰撞检测

工作原理：

**边传输边检测碰撞**，当发现碰撞后停止传输，减少信道浪费。

碰撞检测在有线局域网中比较容易:测量信号强度，比较收、发的信号
在无线局域网中比较困难: 传输时信号的衰减、多径反射

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/08.png" alt="08" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/09.png" alt="09" style="zoom:67%;" />

> 强化碰撞：当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送若干比特的人为干扰信号(jamming signal)，以便让所有用户都知道现在已经发生了碰撞。



最先发送数据帧的站，在发送数据帧后**至多经过多少时间** 就可知道发送的数据帧是否遭受了碰撞？

2t （两倍的端到端时延）

称2t为 ==**争用期**==，或==**碰撞窗口**==





##### 轮流协议

总结上述：

对于信道划分协议：

在重负荷时，共享信道有效、公平；在轻符合时，效率低。

对于随机访问协议：

重负荷时，碰撞开销大；在轻负荷时，当只有一个节点时充分利用信道。

**轮流协议平衡两者。**



以下讨论：

轮询协议、令牌传递协议



==轮询协议==

主节点以循环的方式轮询每个节点。

值得关注：轮询开销、等待时间、单点失效（主节点崩溃影响全网）

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/10.png" alt="10" style="zoom:50%;" />

（动态见ppt44）



==令牌传递协议==

没有主节点，令牌（token）的小的特殊帧在节点之间以某种固定的次序进行交换。

值得关注：令牌开销、等待时间、单点失效（token崩溃影响全网）

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/11.png" alt="11" style="zoom: 50%;" />



#### 交换局域网

##### MAC地址

作用：在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点。

组成：48bit = 前24bit由IEEE分配管理——OUI号 + 后24bit由厂商自行分配。

（e.g.  1A-2F-BB-76-09-AD）

> MAC地址烧入网络适配器的ROM中，不可更改
>
> 局域网中每个适配器有唯一的MAC地址



在不同网络间迁移时，MAC地址不变，而IP地址会改变。



##### ARP（地址解析协议）

背景问题：已知主机IP，如何得知主机MAC

解决方式：ARP高速缓存

局域网节点的IP/MAC地址映射：< IP; MAC ; TTL>  

> *TTL：超过TTL的地址映射会被删除，一般为20min*



工作原理：

> ARP协议工作在同一个子网中，同一个ARP报文不能跨路由器，ARP请求和应答被封装在帧中

1.主机 A 广播**FF-FF-FF-FF-FF-FF** 发送 ARP 请求包

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/12.png" alt="12" style="zoom:50%;" />

2.主机 B **直接**向 A 发送ARP 响应包

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/13.png" alt="13" style="zoom:50%;" />

3.然后主机A更新ARP高速缓存





==提出问题==：若主机A与B不在同一子网下，假设已知主机B的IP，A如何发到B，如下图

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/14.png" alt="14" style="zoom:67%;" />

> 在路由器R中有两个ARP表, 分别针对两个IP网络(LAN)
>
> 从源到目的，穿越几个子网，就发生几次ARP解析

1.主机A直接向R发送IP数据报

A创建IP数据报，源地址为A,目的地址为 B 
A 用ARP获得 R中 111.111.111.110 对应的MAC地址(E6-E9-00-17-BB-4B)
A创建链路层帧(封装A到B的IP数据报)，目的地址为R的MAC地址(E6-E9-00-17-BB-4B)



2.R的适配器接收A的数据报

R从以太帧获取IP数据报，得知它的目的是到B，需要穿过LAN 2



3.R向主机B发送数据报

R用ARP获得B的MAC地址
R创建帧(封装A到B的IP数据报)，发送给B



==例子==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/15.png" alt="15" style="zoom:67%;" />



##### 以太网

* 总线式以太网（共享广播链路）

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/16.png" alt="16" style="zoom:67%;" />

* 交换式以太网（由交换机组建，点到点链路）

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/17.png" alt="17" style="zoom:50%;" />

交换机特点：

* 交换机有很多接口
* 主机直接连到交换机
* 没有碰撞，全双工（如A-to-A'和B-to-B‘同时传输，没有碰撞）



**以太网帧结构**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/18.png" alt="18" style="zoom:67%;" />

* 数据字段（46-1500字节）
* 前同步码（8字节）：前7字节格式为10101010，最后一字节格式为10101011。用于同步发送方和接收方时钟
* 目的地址和源地址（各6字节）：若适配器收到以太网帧，目的地址为自己的MAC地址或广播地址（如ARP包），就将帧中的数据传给网络层。否则，适配器丢弃该帧
* 类型（2字节）：上层协议类型 (大多为IP协议，也支持其它协议，如Novell IPX 和AppleTalk)
* CRC（4字节）：由接收方检查,若检测到错误，就将该帧丢弃



**以太网提供服务**

* 无连接服务
  * 在发送适配器和接收适配器之间不需要握手
* 不可靠服务
  * 接收适配器不发送确认帧或否认帧给发送方
  * 交给网络层的数据报可能存在间隙，若应用使用TCP，间隙会被填充；否则，应用就会看见间隙



**以太网使用的CSMA/CD**

特点：

1. 没有时隙
2. 当适配器侦听到其它适配器在传输，则它不传输帧，即载波侦听
3. 正在传输的适配器若检测到其它适配器也在传输，则它中止自己的传输，即碰撞检测
4. 在重新传输之前，适配器要等待一段随机时间，即随机回退

一些约束：

1. 使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）
2. 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性
3. 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率



几个定义：

**拥塞信号**： 用来确保所有传输者都能检测到碰撞而传输的信号；长度为48比特。

**比特时间**：传输1比特所需时间。在10Mbps的以太网中，当K=1023时，等待时间大约为50ms

算法介绍：

1. 适配器收到来自网络层的数据报，创建帧
2. 若适配器检测到信道空闲，则开始传输帧；若检测到信道忙，就开始等待，直到信道空闲再开始传输该帧
3. 若适配器传输了整个帧而没有检测到其它适配器的传输，则该适配器完成该帧的传输
4. 若适配器在传输时检测到其它适配器也在传输，则停止传输，发送==拥塞信号==
5. 中止传输后，适配器进入==指数回退阶段==，在经历第m次碰撞后，适配器随机从{0,1,2,…,2^m -1}中选择K值。适配器在等待 K*512==比特时间==后，返回第2步

指数回退阶段算法介绍：

目的：适配器重传时试图估计正确的负载。

第一次碰撞后: 从 {0,1}中选择K; 延迟是 K*512 比特传输时间
第二次碰撞后: 从 {0,1,2, 3}中选择K
第十次碰撞后: 从 {0,1,2,3,4,…,1023}中选择K



10M以太网最小帧长为64字节。

首部（目的MAC地址+源MAC地址）（12字节）+尾部（CRC）（4字节） + 类型（2字节） = 18字节

则数据字段最少46字节。



**争用期长度**（以太网取 51.2 微秒 为争用期长度）

对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节

以太网在发送数据时，若前 64 字节没有发生碰撞，则后续的数据就不会发生碰撞



**最短有效帧长**

如果发生碰撞，就一定是在发送的前 64 字节之内

由于一检测到碰撞就立即中止发送，这时已经发送出去的数据一定小于 64 字节 

==以太网规定了最短有效帧长为 64 字节==，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧 







##### 传统以太网的物理层

> 黄色部分为物理层

**链路介质**

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/19.png" alt="19" style="zoom:67%;" />

如10BaseT  and  100BaseT

* 10、100表示速率

* T表示双绞线（Twisted Pair）
* 在节点和集线器之间的最大距离为100 米



**信号编码**

以太网使用基带传输，在10BaseT中可使用曼彻斯特编码

每个比特会有一次跳变，可用于收发双方节点的时钟同步。



介绍两个编码方式：

1.曼彻斯特编码

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/20.png" alt="20" style="zoom:50%;" />

2.差分曼彻斯特编码

> 传输的是"1"还是"0"，是在每个时钟位的开始有无跳变来区分的

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/21.png" alt="21" style="zoom:50%;" />



扩展：

快速以太网：速率达到100Mbps

吉比特以太网：速率达到1000Mbps

* 使用标准以太网帧格式，因此还叫以太网
* 允许点对点链路(交换式以太网)和共享的广播信道(共享式以太网)
* 共享信道时, 使用CSMA/CD; 为了得到可接受的效率，节点之间的距离要短
* 对于点到点链路(不会碰撞，不需要CSMA/CD)，可以以1Gbps的速率全双工工作
* 现在速率已经达到10 Gbps !





##### 链路层网络设备

**集线器（hub）**

集线器本质上是物理层的中继器

特点：

* 从一个接口收到的比特流会传给其它所有接口
* 两个集线器之间必须同样速率，即10M的hub 和100M的hub 不能互连
* 没有帧缓存
* 集线器没有 CSMA/CD : 由适配器检测碰撞，即如果集线器同时从两个不同的接口接收到帧，则出现一次碰撞，需要发送帧的节点重新发送。
* 提供网络管理功能



**集线器（或转发器）互联**

主干集线器将LAN网段互联起来，扩展了节点间的最大距离

但原先独立的==网段==碰撞域变成了一个大的碰撞域，且不能将10BaseT 和 100BaseT以太网互联

> 解释名词：交换机一个端口是一个网段，路由器一个端口是一个子网





**交换机（switch）**

特点：

* 链路层设备，用于存储和转发以太网帧。具体是，检查帧头部，根据目的MAC地址转发帧。
* 透明，主机不知道交换机的存在
* 即插即用，自学习。即交换机不需要配置。

交换机（Swtich）是一种存储—转发设备，在MAC层实现LAN互连



**以太网交换机互联**

概念结构：

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/22.png" alt="22" style="zoom:50%;" />

工作原理：

* 不断监听各接口是否有信号
* 收到无差错的帧则缓存，反之则丢弃
* 若收到的帧的目的MAC地址属于另一网段，则通过站表决定向对应接口转发
* 交换机不转发同一个网段内通信的帧，即MAC1到MAC2不经过交换机转发
* 交换机不修改转发的帧的源MAC地址和目的MAC地址



<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/23.png" alt="23" style="zoom: 67%;" />



**==交换机——自学习==**

交换表项：< MAC地址；接口； 时间戳 >  

*TTL 可能为 60分钟*

自学习方式：交换机能学习到哪个主机从哪个接口到达。当收到帧的时候，交换机学习发送者进入的端口号，在交换表中记录< 发送者/位置 >对 。



举个例子：

假定C发送帧到D。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/24.png" alt="24" style="zoom: 67%;" />

1.初始时，交换机的交换表为

| 地址 | 接口 |
| :--: | :--: |
|  A   |  1   |
|  B   |  1   |
|  E   |  2   |
|  G   |  3   |



2.交换机接收来自C的帧，在交换表中增加<C 1>

| 地址 | 接口 |
| :--: | :--: |
|  A   |  1   |
|  B   |  1   |
|  E   |  2   |
|  G   |  3   |
|  C   |  1   |



3.因为D不在表中，交换机将帧转发到接口2和3。

> 交换机不转发同一网段，如A转发到B，交换机不管

4.D接收到帧，有数据返回给C

5.交换机接收到D的帧，在表中增加<D 2>

| 地址 | 接口 |
| :--: | :--: |
|  A   |  1   |
|  B   |  1   |
|  E   |  2   |
|  G   |  3   |
|  C   |  1   |
|  D   |  2   |

6.交换表中有C，则交换机只将帧转发到接口1

7.C收到该帧，数据传输结束



**交换机——流量隔离**

交换机将子网分成了LAN网段

交换机实现包过滤：同一LAN网段的帧不会和其它LAN网段的帧碰撞，网段保持独立的碰撞域。



**交换机——专用接入（点对点）**

交换机有很多接口，主机“直接”连到交换机。

没有碰撞，全双工

由于每条链路变成了点对点链路，因此载波监听和碰撞检测不再需要

同时每个主机和交换机端口间的连接使用两对双绞线，因此每个主机可以工作在全双工模式下

帧的格式不变，因此仍然叫以太网



==一个网络示例==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/25.png" alt="25" style="zoom: 67%;" />





**交换机优劣势**

优点：

* 过滤了通信量
* 扩大了局域网的物理范围
* 提高了可靠性
* 可==互联不同物理层、不同MAC子层和不同速率的局域网==
* ==流量隔离==，不会扩大碰撞域



缺点：

* 由于要接收和转发，==增加了时延==
* MAC子层没有流量控制功能，网络负荷重时，交换机缓存空间可能发生溢出，产生==帧丢失==现象
* 出现==广播风暴==。交换机只适合用户少于几百个和通信量不太大的局域网，否则有时会因传播过多广播信息而产生网络拥塞



**交换机——透明性**

“透明”是指 局域网上的每个站并不知道所发送的帧将经过哪几个交换机，即交换机对各站来说是看不见的





==**交换机 vs 集线器**==

1.扩展局域网方面：

* 集线器只是将网络的覆盖距离简单的延长，而且距离有限，具体实现在物理层
* 交换机不仅具有将LAN的覆盖距离延长的作用，而且理论上可做到无限延长，具体实现在MAC层

2.信号处理能力：

* 集线器仅具有简单的信号整形和放大的功能
* 交换机则属于一种智能互连设备，它主要提供信号的存储/转发、数据过滤、路由选择等能力

3.设备属性：

* 集线器仅是一种硬设备
* 而交换机既包括硬件又包括软件



==**交换机 vs 路由器**==

1.设备属性：

* 两者都是存储转发设备
* 路由器是网络层设备
* 交换机是链路层设备

2.一些算法：

* 路由器维护路由表，实现路由算法
* 交换机维护交换表，实现MAC地址过滤、自学习算法



|          | 集线器 | 路由器 | 交换机 |
| :------: | :----: | :----: | :----: |
| 流量隔离 |   ×    |   √    |   √    |
| 即插即用 |   √    |   ×    |   √    |
| 优化选路 |   ×    |   √    |   √    |
| 直通交换 |   √    |   ×    |   √    |





##### 虚拟局域网VLAN

虚拟局域网VLAN*（Virtual LAN）*是指以软件方式来实现逻辑工作组划分与管理的一种网络工作组组建技术。

特点：

* 局域网交换机是组建虚拟局域网的核心设备
* 组成逻辑工作组的各结点==不受物理位置的限制==，换言之，同一逻辑工作组的成员不一定要连接在同一个物理网段（交换机端口）上
* 当一个结点从一个逻辑工作组转移到另一个逻辑工作组时，只需要通过软件设定，而==不需要改变它在网络中的物理位置==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/26.png" alt="26" style="zoom: 67%;" />

构建VLAN方式：

* 基于交换机接口号（端口号）
* 基于MAC地址
* 基于IP地址



==基于端口的VLAN==

交换机端口被分成多组（由交换机管理软件完成），单个物理交换机可以被划分为多个虚拟交换机，如下图

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/27.png" alt="27" style="zoom:67%;" />

> 划分VLAN后，逻辑上是二个互不相连的交换机各自组成一个局域网，因此这二个VLAN是不通的，如绿色和黄色部分不相通

* 流量隔离

如来自1-8号端口的帧仅能发送到1-8端口。

* 动态成员管理

端口可以在VALN之间动态分配，如把绿3变成黄色的部分。

* VLAN之间的转发

通过路由完成转发（就像使用单独的交换机一样）

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/28.png" alt="28" style="zoom:67%;" />

* 跨交换机实现VLAN划分

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/29.png" alt="29" style="zoom:67%;" />

相关知识：干线端口（trunk port）

 转发在多个物理交换机上定义的VLAN帧，如图中左边交换机的16端口，右边交换机1端口。

VLAN帧是基于802.1q协议的VLAN帧格式

> **IEEE 802.1**是一组协议的集合，如[生成树协议](https://baike.so.com/doc/5869481-6082340.html)、[VLAN协议](https://baike.so.com/doc/5506707-5742452.html)等 。为了将各个协议区别开来，IEEE在制定某一个协议时，就在IEEE 802.1后面加上不同的小写字母，如IEEE 802.1a定义局域网[体系结构](https://baike.so.com/doc/6477885-6691588.html);IEEE 802.1b定义网际互连，网络管理及寻址;IEEE 802.1d定义生成树协议;IEEE 802.1p定义[优先级队列](https://baike.so.com/doc/2385820-2522667.html);IEEE [802.1q](https://baike.so.com/doc/5439973-5678297.html)定义VLAN标记协议;IEEE[802.1s](https://baike.so.com/doc/1439183-1521308.html)定义[多生成树协议](https://baike.so.com/doc/1283708-1357397.html);IEEE [802.1w](https://baike.so.com/doc/1087420-1150707.html)定义快速生成树协议;IEEE [802.1x](https://baike.so.com/doc/3162953-3333370.html)定义局域网安全认证等。

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/30.png" alt="30" style="zoom:67%;" />

> 绿色部分为tag的具体内容

每一个VLAN的帧都有一个明确的标识符（VID），指明发送这个帧的主机属于哪一个VLAN



由于支持VLAN的以太网帧格式与普通以太网帧格式相比格式不同，因此普通的以太网链路是不能传输不同VLAN间的VLAN帧的。

要使得一条链路能传输不同VLAN之间的帧，必须把这条链路配置成VLAN干道（Trunk）。那么那些具有不同VLAN ID的VLAN帧都可以通过这条链路。

因此，以太网的链路可以分为2种：==Access==和==Trunk==。

Access链路里跑原始的帧，不支持VLAN。

Trunk链路里跑VLAN帧，如果VLAN要跨设备实现，那么连接两设备的链路必须是Trunk链路，即用来连接两设备的端口必须Trunk，否则VLAN帧不能传到其它设备。



==一个例子==

<img src="https://raw.githubusercontent.com/fly-lovest/HUST-CS-Computer-Communication-and-Networking/main/images/L6/31.png" alt="31" style="zoom:67%;" />

普通链路上的以太网帧进入左边交换机后，交换机将其改成VLAN帧，再通过trunk发送右边交换机，右边交换机再将其还原成普通以太网帧后发送给目标主机。

*注意*：在这个过程中会根据VLAN ID往相应端口发，不是同一个VLAN的端口不会发。因此不同VLAN的主机间是不通的，除非配置了路由。

并且当交换机需要广播时，会根据VLANID往相应端口发，不是同一个ID的VLAN端口不发。因此不同的VLAN是不同的广播域。
